<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>昭佳宁的博客</title>
  
  <subtitle>Johnny&#39;s Blog</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-05-19T13:32:54.719Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Johnny Zhao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ASP.NET MVC中的Global.asax文件</title>
    <link href="http://example.com/2020/05/19/ASP.NET%20MVC%E4%B8%AD%E7%9A%84Global.asax%E6%96%87%E4%BB%B6/"/>
    <id>http://example.com/2020/05/19/ASP.NET%20MVC%E4%B8%AD%E7%9A%84Global.asax%E6%96%87%E4%BB%B6/</id>
    <published>2020-05-19T13:20:00.000Z</published>
    <updated>2020-05-19T13:32:54.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="global-asax文件概述"><a href="#global-asax文件概述" class="headerlink" title="global.asax文件概述"></a>global.asax文件概述</h1><p>Global.asax这个文件包含全局应用程序事件的事件处理程序。它响应应用程序级别和会话级别事件的代码。　　<br>运行时， Global.asax 将被编译成一个动态生成的 <code>.NET Framework</code> 类，该类是从 <code>HttpApplication</code> 基类派生的。<br>因此在 Global.asax 中的代码可以访问 <code>HttpApplication</code> 类中所有的 <code>public</code> 或者 <code>protected</code> 的成员<br>Global.asax 不被用户直接请求，但 Global.asax 中的代码会被自动执行来响应特定的应用程序事件。<br>Global.asax 是可选的，而且在一个 web 项目中是唯一的，它应该处于网站的根目录。</p><a id="more"></a><h1 id="一个请求的完整处理过程"><a href="#一个请求的完整处理过程" class="headerlink" title="一个请求的完整处理过程"></a>一个请求的完整处理过程</h1><p>以下过程由 <code>Internet Information Service（inetinfo.exe）（IIS）</code>执行</p><ul><li>客户端发出请求</li><li>验证请求</li><li>给请求授权</li><li>确定请求的缓存</li><li>获取缓存状态</li><li>在请求的处理程序执行前</li><li>http 处理程序执行请求 （asp.net 页面由 aspnet_wp.exe 执行）</li><li>在请求的处理程序执行后</li><li>释放请求状态</li><li>更新请求缓存</li><li>请求结束</li></ul><h1 id="Global-asax中的事件"><a href="#Global-asax中的事件" class="headerlink" title="Global.asax中的事件"></a>Global.asax中的事件</h1><p>Global.asax中的所有事件可以分成两种，一种是满足特定事件时才会被触发，一种是每次请求都会被按照顺序执行的事件。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MvcApplication</span> : <span class="title">System.Web.HttpApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Application_Start</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//不是每次请求都调用</span></span><br><span class="line">        <span class="comment">//在Web应用程序的生命周期里就执行一次</span></span><br><span class="line">        <span class="comment">//在应用程序第一次启动和应用程序域创建事被调用</span></span><br><span class="line">        <span class="comment">//适合处理应用程序范围的初始化代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Application_End</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//不是每次请求都调用</span></span><br><span class="line">        <span class="comment">//在应用程序关闭时运行的代码，在最后一个HttpApplication销毁之后执行</span></span><br><span class="line">        <span class="comment">//比如IIS重启，文件更新，进程回收导致应用程序转换到另一个应用程序域</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Session_Start</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//不是每次请求都调用</span></span><br><span class="line">        <span class="comment">//会话开始时执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Session_End</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//不是每次请求都调用</span></span><br><span class="line">        <span class="comment">//会话结束或过期时执行</span></span><br><span class="line">        <span class="comment">//不管在代码中显式的清空Session或者Session超时自动过期，此方法都将被调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Application_Init</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//不是每次请求都调用</span></span><br><span class="line">        <span class="comment">//在每一个HttpApplication实例初始化的时候执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Application_Disposed</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//不是每次请求都调用</span></span><br><span class="line">        <span class="comment">//在应用程序被关闭一段时间之后，在.net垃圾回收器准备回收它占用的内存的时候被调用。</span></span><br><span class="line">        <span class="comment">//在每一个HttpApplication实例被销毁之前执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Application_Error</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//不是每次请求都调用</span></span><br><span class="line">        <span class="comment">//所有没有处理的错误都会导致这个方法的执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*********************************************************************/</span></span><br><span class="line">    <span class="comment">//每次请求都会按照顺序执行以下事件</span></span><br><span class="line">    <span class="comment">/*********************************************************************/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Application_BeginRequest</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//每次请求时第一个出发的事件，这个方法第一个执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Application_AuthenticateRequest</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//在执行验证前发生，这是创建验证逻辑的起点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Application_AuthorizeRequest</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//当安全模块已经验证了当前用户的授权时执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Application_ResolveRequestCache</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//当ASP.NET完成授权事件以使缓存模块从缓存中为请求提供服务时发生，从而跳过处理程序（页面或者是WebService）的执行。</span></span><br><span class="line">        <span class="comment">//这样做可以改善网站的性能，这个事件还可以用来判断正文是不是从Cache中得到的。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//在这个时候，请求将被转交给合适程序。例如：web窗体将被编译并完成实例化</span></span><br><span class="line">    <span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Application_AcquireRequestState</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//读取了Session所需的特定信息并且在把这些信息填充到Session之前执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Application_PreRequestHandlerExecute</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//在合适的处理程序执行请求前调用</span></span><br><span class="line">        <span class="comment">//这个时候，Session就可以用了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//-------------------------------------------------</span></span><br><span class="line">    <span class="comment">//在这个时候，页面代码将会被执行，页面呈现为HTML</span></span><br><span class="line">    <span class="comment">//-------------------------------------------------</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Application_PostRequestHandlerExecute</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//当处理程序完成对请求的处理后被调用。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Application_ReleaseRequestState</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//释放请求状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Application_UpdateRequestCache</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//为了后续的请求，更新响应缓存时被调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Application_EndRequest</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//EndRequest是在响应Request时最后一个触发的事件</span></span><br><span class="line">        <span class="comment">//但在对象被释放或者从新建立以前，适合在这个时候清理代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Application_PreSendRequestHeaders</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//向客户端发送Http标头之前被调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Application_PreSendRequestContent</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//向客户端发送Http正文之前被调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;global-asax文件概述&quot;&gt;&lt;a href=&quot;#global-asax文件概述&quot; class=&quot;headerlink&quot; title=&quot;global.asax文件概述&quot;&gt;&lt;/a&gt;global.asax文件概述&lt;/h1&gt;&lt;p&gt;Global.asax这个文件包含全局应用程序事件的事件处理程序。它响应应用程序级别和会话级别事件的代码。　　&lt;br&gt;运行时， Global.asax 将被编译成一个动态生成的 &lt;code&gt;.NET Framework&lt;/code&gt; 类，该类是从 &lt;code&gt;HttpApplication&lt;/code&gt; 基类派生的。&lt;br&gt;因此在 Global.asax 中的代码可以访问 &lt;code&gt;HttpApplication&lt;/code&gt; 类中所有的 &lt;code&gt;public&lt;/code&gt; 或者 &lt;code&gt;protected&lt;/code&gt; 的成员&lt;br&gt;Global.asax 不被用户直接请求，但 Global.asax 中的代码会被自动执行来响应特定的应用程序事件。&lt;br&gt;Global.asax 是可选的，而且在一个 web 项目中是唯一的，它应该处于网站的根目录。&lt;/p&gt;</summary>
    
    
    
    
    <category term=".NET" scheme="http://example.com/tags/NET/"/>
    
    <category term="MVC" scheme="http://example.com/tags/MVC/"/>
    
    <category term="Global" scheme="http://example.com/tags/Global/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式 数字判断</title>
    <link href="http://example.com/2020/05/18/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%20%E6%95%B0%E5%AD%97%E5%88%A4%E6%96%AD/"/>
    <id>http://example.com/2020/05/18/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%20%E6%95%B0%E5%AD%97%E5%88%A4%E6%96%AD/</id>
    <published>2020-05-18T13:05:00.000Z</published>
    <updated>2020-09-24T12:24:35.054Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="整数判断"><a href="#整数判断" class="headerlink" title="整数判断"></a>整数判断</h1><ol><li><p>判断整数<br><code>&quot;^-?\d+$&quot;</code></p></li><li><p>判断正整数<br><code>&quot;^\d*[1-9]\d*$&quot;</code></p></li><li><p>判断负整数<br><code>&quot;^-\d*[1-9]\d*$&quot;</code></p></li><li><p>判断非正整数<br><code>&quot;^((-\d+)|(0+))$&quot;</code></p></li><li><p>判断非负整数<br><code>&quot;^\d+$&quot;</code></p></li></ol><h1 id="浮点数判断"><a href="#浮点数判断" class="headerlink" title="浮点数判断"></a>浮点数判断</h1><ol><li>判断浮点数<br><code>&quot;^(-?\d+)(\.\d+)?$&quot;</code></li><li>判断正浮点数<br><code>&quot;^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$&quot;</code></li><li>判断负浮点数<br><code>&quot;^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$&quot;</code></li><li>判断非正浮点数<br><code>&quot;^((-\d+(\.\d+)?)|(0+(\.0+)?))$&quot;</code></li><li>判断非负浮点数<br><code>&quot;^\d+(\.\d+)?$&quot;</code></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;整数判断&quot;&gt;&lt;a href=&quot;#整数判断&quot; class=&quot;headerlink&quot; title=&quot;整数判断&quot;&gt;&lt;/a&gt;整数判断&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;判断整数&lt;br&gt;&lt;code&gt;&amp;quot;^-?\d+$&amp;quot;&lt;</summary>
      
    
    
    
    
    <category term="Regex" scheme="http://example.com/tags/Regex/"/>
    
    <category term="正则" scheme="http://example.com/tags/%E6%AD%A3%E5%88%99/"/>
    
    <category term="数字判断" scheme="http://example.com/tags/%E6%95%B0%E5%AD%97%E5%88%A4%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>c#中的Cache缓存技术</title>
    <link href="http://example.com/2020/04/15/C#%E4%B8%AD%E7%9A%84Cache%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/"/>
    <id>http://example.com/2020/04/15/C#%E4%B8%AD%E7%9A%84Cache%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/</id>
    <published>2020-04-14T16:00:00.000Z</published>
    <updated>2020-05-19T13:33:25.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c-中的Cache缓存技术"><a href="#c-中的Cache缓存技术" class="headerlink" title="c#中的Cache缓存技术"></a>c#中的Cache缓存技术</h1><h2 id="Cache缓存类"><a href="#Cache缓存类" class="headerlink" title="Cache缓存类"></a>Cache缓存类</h2><ul><li><p>1、HttpRuntime.Cache 相当于就是一个缓存具体实现类，这个类虽然被放在了 System.Web 命名空间下了。但是非 Web 应用也是可以拿来用的。</p></li><li><p>2、HttpContext.Cache 是对上述缓存类的封装，由于封装到了 HttpContext ，局限于只能在知道 HttpContext 下使用，即只能用于 Web 应用。</p></li></ul><p>综上所属，在可以的条件，尽量用 HttpRuntime.Cache ，而不是用 HttpContext.Cache 。 </p><a id="more"></a><h2 id="Cache缓存数据规则"><a href="#Cache缓存数据规则" class="headerlink" title="Cache缓存数据规则"></a>Cache缓存数据规则</h2><p>Cache有以下几条缓存数据的规则。</p><ul><li><p>第一，数据可能会被频繁的被使用，这种数据可以缓存。</p></li><li><p>第二，数据的访问频率非常高，或者一个数据的访问频率不高，但是它的生存周期很长，这样的数据最好也缓存起来。</p></li><li><p>第三是一个常常被忽略的问题，有时候我们缓存了太多数据，通常在一台 X86 的机子上，如果你要缓存的数据超过 800M 的话，就会出现内存溢出的错误。所以说缓存是有限的。换名话说，你应该估计缓存集的大小，把缓存集的大小限制在 10 以内，否则它可能会出问题。</p></li></ul><h2 id="Cache的操作"><a href="#Cache的操作" class="headerlink" title="Cache的操作"></a>Cache的操作</h2><h3 id="cache的创建"><a href="#cache的创建" class="headerlink" title="cache的创建"></a>cache的创建</h3><p><code>cache.Insert(string key,object value,CacheDependency dependencies,DateTime absoluteExpiration,TimeSpan slidingExpiration)</code></p><p><strong>只介绍有5个参数的情况，其实cache里有很几种重载</strong></p><ul><li><p>参数一：引用该对象的缓存键</p></li><li><p>参数二：要插入缓存中的对象</p></li><li><p>参数三：缓存键的依赖项，当任何依赖项更改时，该对象即无效，并从缓存中移除。 null.”&gt;如果没有依赖项，则此参数包含 null。</p></li><li><p>参数四：设置缓存过期时间</p></li><li><p>参数五：参数四的依赖项，如果使用绝对到期，null.”&gt;slidingExpiration parameter must beNoSlidingExpiration.”&gt;则 slidingExpiration 参数必须为 NoSlidingExpiration</p></li></ul><h3 id="销毁cache"><a href="#销毁cache" class="headerlink" title="销毁cache"></a>销毁cache</h3><p><code>cache.Remove(string key)</code></p><p>key为缓存键，通过缓存键进行销毁</p><h3 id="调用cache"><a href="#调用cache" class="headerlink" title="调用cache"></a>调用cache</h3><p>例如你存的是一个 DataTable 对象，调用如下： </p><p><code>DataTable finaltable = Cache[&quot;dt&quot;] as DataTable;</code></p><h3 id="一般什么时候选用cache"><a href="#一般什么时候选用cache" class="headerlink" title="一般什么时候选用cache"></a>一般什么时候选用cache</h3><p>cache一般用于数据较固定，访问较频繁的地方，例如在前端进行分页的时候，初始化把数据放入缓存中，然后每次分页都从缓存中取数据，这样减少了连接数据库的次数，提高了系统的性能。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;  </span><br><span class="line">&#x2F;&#x2F;&#x2F; 获取数据缓存  </span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;  </span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;cacheKey&quot;&gt;键&lt;&#x2F;param&gt;  </span><br><span class="line">public static object GetCache(string cacheKey)  </span><br><span class="line">&#123;  </span><br><span class="line">    var objCache &#x3D; HttpRuntime.Cache.Get(cacheKey);  </span><br><span class="line">    return objCache;  </span><br><span class="line">&#125;  </span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;  </span><br><span class="line">&#x2F;&#x2F;&#x2F; 设置数据缓存  </span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;  </span><br><span class="line">public static void SetCache(string cacheKey, object objObject)  </span><br><span class="line">&#123;  </span><br><span class="line">    var objCache &#x3D; HttpRuntime.Cache;  </span><br><span class="line">    objCache.Insert(cacheKey, objObject);  </span><br><span class="line">&#125;  </span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;  </span><br><span class="line">&#x2F;&#x2F;&#x2F; 设置数据缓存  </span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;  </span><br><span class="line">public static void SetCache(string cacheKey, object objObject, int timeout &#x3D; 7200)  </span><br><span class="line">&#123;  </span><br><span class="line">    try  </span><br><span class="line">    &#123;  </span><br><span class="line">        if (objObject &#x3D;&#x3D; null) return;  </span><br><span class="line">        var objCache &#x3D; HttpRuntime.Cache;  </span><br><span class="line">        &#x2F;&#x2F;相对过期  </span><br><span class="line">        &#x2F;&#x2F;objCache.Insert(cacheKey, objObject, null, DateTime.MaxValue, timeout, CacheItemPriority.NotRemovable, null);  </span><br><span class="line">        &#x2F;&#x2F;绝对过期时间  </span><br><span class="line">        objCache.Insert(cacheKey, objObject, null, DateTime.Now.AddSeconds(timeout), TimeSpan.Zero, CacheItemPriority.High, null);  </span><br><span class="line">    &#125;  </span><br><span class="line">    catch (Exception)  </span><br><span class="line">    &#123;  </span><br><span class="line">        &#x2F;&#x2F;throw;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;  </span><br><span class="line">&#x2F;&#x2F;&#x2F; 移除指定数据缓存  </span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;  </span><br><span class="line">public static void RemoveAllCache(string cacheKey)  </span><br><span class="line">&#123;  </span><br><span class="line">    var cache &#x3D; HttpRuntime.Cache;  </span><br><span class="line">    cache.Remove(cacheKey);  </span><br><span class="line">&#125;  </span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;  </span><br><span class="line">&#x2F;&#x2F;&#x2F; 移除全部缓存  </span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;  </span><br><span class="line">public static void RemoveAllCache()  </span><br><span class="line">&#123;  </span><br><span class="line">    var cache &#x3D; HttpRuntime.Cache;  </span><br><span class="line">    var cacheEnum &#x3D; cache.GetEnumerator();  </span><br><span class="line">    while (cacheEnum.MoveNext())  </span><br><span class="line">    &#123;  </span><br><span class="line">        cache.Remove(cacheEnum.Key.ToString());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;c-中的Cache缓存技术&quot;&gt;&lt;a href=&quot;#c-中的Cache缓存技术&quot; class=&quot;headerlink&quot; title=&quot;c#中的Cache缓存技术&quot;&gt;&lt;/a&gt;c#中的Cache缓存技术&lt;/h1&gt;&lt;h2 id=&quot;Cache缓存类&quot;&gt;&lt;a href=&quot;#Cache缓存类&quot; class=&quot;headerlink&quot; title=&quot;Cache缓存类&quot;&gt;&lt;/a&gt;Cache缓存类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1、HttpRuntime.Cache 相当于就是一个缓存具体实现类，这个类虽然被放在了 System.Web 命名空间下了。但是非 Web 应用也是可以拿来用的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2、HttpContext.Cache 是对上述缓存类的封装，由于封装到了 HttpContext ，局限于只能在知道 HttpContext 下使用，即只能用于 Web 应用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;综上所属，在可以的条件，尽量用 HttpRuntime.Cache ，而不是用 HttpContext.Cache 。 &lt;/p&gt;</summary>
    
    
    
    
    <category term=".Net" scheme="http://example.com/tags/Net/"/>
    
    <category term="C#" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>SQL server Date 数据类型</title>
    <link href="http://example.com/2020/04/15/SQL%20Date%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://example.com/2020/04/15/SQL%20Date%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-04-14T16:00:00.000Z</published>
    <updated>2020-05-19T13:33:14.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL-server-Date-数据类型"><a href="#SQL-server-Date-数据类型" class="headerlink" title="SQL server Date 数据类型"></a>SQL server Date 数据类型</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在图书管理系统的练习中，想到可以通过日期筛选图书</p><p>然后又是因为用到了存储过程，所以时间操作必定要在数据库中完成</p><p>所以就简单的看了下 SQL server 的 Date 数据类型和相关的内置函数</p><a id="more"></a><h2 id="Date分类"><a href="#Date分类" class="headerlink" title="Date分类"></a>Date分类</h2><p>Date 数据类型可以分为一下几种：</p><table><thead><tr><th>数据类型</th><th>描述</th><th>样式</th><th>存储</th></tr></thead><tbody><tr><td>date</td><td>仅存储日期。从 0001 年 1 月 1 日 到 9999 年 12 月 31 日。</td><td>2020-04-15</td><td>3 bytes</td></tr><tr><td>time</td><td>仅存储时间。精度为 100 纳秒。</td><td>13:23:22.5333333</td><td>3-5 bytes</td></tr><tr><td>datetime</td><td>从 1753 年 1 月 1 日 到 9999 年 12 月 31 日 <br> 精度为 3.33 毫秒。</td><td>2020-04-15 13:24:16.920</td><td>8 bytes</td></tr><tr><td>datetime2</td><td>从 1753 年 1 月 1 日 到 9999 年 12 月 31 日 <br> 精度为 100 纳秒。（ datetime的升级版 ）</td><td>2020-04-15 13:26:07.8100000</td><td>6-8 bytes</td></tr><tr><td>smalldatetime</td><td>从 1900 年 1 月 1 日 到 2079 年 6 月 6 日 <br> 精度为 1 分钟。</td><td>2020-04-15 13:27:00</td><td>4 bytes</td></tr><tr><td>datetimeoffset</td><td>与 datetime2 相同 <br> 外加时区偏移。</td><td>2020-04-15 13:28:01.3133333 +00:00</td><td>8-10 bytes</td></tr><tr><td>timestamp</td><td>存储唯一的数字，每当创建或修改某行时，该数字会更新。 <br> timestamp 基于内部时钟，不对应真实时间。 <br> 每个表只能有一个 timestamp 变量。（ 时间戳 ）</td><td>0x0000000000000FA0</td><td></td></tr></tbody></table><p>若需要手写日期类型，只需要按照样式的仿写然后用引号括起来即可</p><p>如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">declare @timeDemo datetime</span><br><span class="line">set @timeDemo &#x3D; &#39;2020-1-1 12:30:45.123&#39;</span><br><span class="line">select @timeDemo as timeDemo</span><br></pre></td></tr></table></figure><p>会得到以下结果</p><table><thead><tr><th>timeDemo</th></tr></thead><tbody><tr><td>2020-01-01 12:30:45.123</td></tr></tbody></table><p><strong>不过要注意，手写的内容必须合法，不然程序会报错！</strong></p><h2 id="Date映射关系"><a href="#Date映射关系" class="headerlink" title="Date映射关系"></a>Date映射关系</h2><table><thead><tr><th>SQL 数据类型</th><th>.NET Framework 类型</th><th>System.Data.SqlDbType</th></tr></thead><tbody><tr><td>date</td><td>System.DateTime</td><td>Date</td></tr><tr><td>time</td><td>System.TimeSpan</td><td>Time</td></tr><tr><td>datetime</td><td>System.DateTime</td><td>DateTime</td></tr><tr><td>datetime2</td><td>System.DateTime</td><td>DateTime2</td></tr><tr><td>smalldatetime</td><td>System.DateTime</td><td>DateTime</td></tr><tr><td>datetimeoffset</td><td>System.DateTimeOffset</td><td>DateTimeOffset</td></tr></tbody></table><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><h3 id="getdate"><a href="#getdate" class="headerlink" title="getdate()"></a>getdate()</h3><p>getdate() 函数从 SQL Server 返回当前的时间和日期。</p><p>如使用如下语句</p><p><code>select getdate() as timeDemo</code></p><p>会得到以下结果</p><table><thead><tr><th>timeDemo</th></tr></thead><tbody><tr><td>2020-04-15 13:41:33.317</td></tr></tbody></table><h3 id="datepart"><a href="#datepart" class="headerlink" title="datepart()"></a>datepart()</h3><p>datepart() 函数用于返回日期/时间的单独部分，比如年、月、日、小时、分钟等等。</p><p>语法</p><p><code>datepart(datepart,date)</code></p><p>其中，date 参数是合法的日期表达式。datepart 参数可以是下列的值：</p><table><thead><tr><th>datepart</th><th>缩写</th></tr></thead><tbody><tr><td>年</td><td>yy,yyyy</td></tr><tr><td>季度</td><td>qq,q</td></tr><tr><td>月</td><td>mm,m</td></tr><tr><td>年中的日</td><td>dy,y</td></tr><tr><td>日</td><td>dd,d</td></tr><tr><td>周</td><td>wk,ww</td></tr><tr><td>星期</td><td>dw,w</td></tr><tr><td>小时</td><td>hh</td></tr><tr><td>分钟</td><td>mi,n</td></tr><tr><td>秒</td><td>ss,s</td></tr><tr><td>毫秒</td><td>ms</td></tr><tr><td>微秒</td><td>mcs</td></tr><tr><td>纳秒</td><td>ns</td></tr></tbody></table><p>如使用如下语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select datepart(yyyy,getdate()) as Year,</span><br><span class="line">datepart(mm,getdate()) as Month,</span><br><span class="line">datepart(dd,getdate()) as Day</span><br></pre></td></tr></table></figure><p>会得到以下结果</p><table><thead><tr><th>Year</th><th>Month</th><th>Day</th></tr></thead><tbody><tr><td>2020</td><td>4</td><td>15</td></tr></tbody></table><h3 id="dateadd"><a href="#dateadd" class="headerlink" title="dateadd()"></a>dateadd()</h3><p>dateadd() 函数在日期中添加或减去指定的时间间隔。</p><p>语法</p><p><code>dateadd(datepart,number,date)</code></p><p>date 参数是合法的日期表达式。number 是您希望添加的间隔数；对于未来的时间，此数是正数，对于过去的时间，此数是负数。</p><p>datepart 参数上面已经介绍。</p><p>如使用如下语句</p><p><code>select dateadd(yy,1,&#39;2020-1-1&#39;) as nextYear</code></p><p>会得到以下结果</p><table><thead><tr><th>nextYear</th></tr></thead><tbody><tr><td>2021-01-01 00:00:00.000</td></tr></tbody></table><h3 id="datediff"><a href="#datediff" class="headerlink" title="datediff()"></a>datediff()</h3><p>datediff() 函数返回两个日期之间的时间。</p><p>语法</p><p><code>datediff(datepart,number,date)</code></p><p>startdate 和 enddate 参数是合法的日期表达式。</p><p>datepart 参数上面已经介绍。</p><p>如使用如下语句</p><p><code>select datediff(dd,&#39;2020-01-01&#39;,&#39;2020-01-02&#39;) as timeDiffer</code></p><p>会得到以下结果</p><table><thead><tr><th>timeDiffer</th></tr></thead><tbody><tr><td>1</td></tr></tbody></table><h3 id="convert"><a href="#convert" class="headerlink" title="convert()"></a>convert()</h3><p>convert() 函数是把日期转换为新数据类型的通用函数。<br>convert() 函数可以用不同的格式显示日期/时间数据。</p><p>语法</p><p><code>convert(data_type(length),data_to_be_converted,style)</code></p><p>data_type(length) 规定目标数据类型（带有可选的长度）。data_to_be_converted 含有需要转换的值。style 规定日期/时间的输出格式。</p><p>style可以使用下列值</p><table><thead><tr><th>style ID</th><th>style 格式</th></tr></thead><tbody><tr><td>100 或 0</td><td>mon dd yyyy hh:miAM （或者 PM）</td></tr><tr><td>101</td><td>mm/dd/yy</td></tr><tr><td>102</td><td>yy.mm.dd</td></tr><tr><td>103</td><td>dd/mm/yy</td></tr><tr><td>104</td><td>dd.mm.yy</td></tr><tr><td>105</td><td>dd-mm-yy</td></tr><tr><td>106</td><td>dd mon yy</td></tr><tr><td>107</td><td>Mon dd, yy</td></tr><tr><td>108</td><td>hh:mm:ss</td></tr><tr><td>109 或 9</td><td>mon dd yyyy hh:mi:ss:mmmAM（或者 PM）</td></tr><tr><td>110</td><td>mm-dd-yy</td></tr><tr><td>111</td><td>yy/mm/dd</td></tr><tr><td>112</td><td>yymmdd</td></tr><tr><td>113 或 13</td><td>dd mon yyyy hh:mm:ss:mmm(24h)</td></tr><tr><td>114</td><td>hh:mi:ss:mmm(24h)</td></tr><tr><td>120 或 20</td><td>yyyy-mm-dd hh:mi:ss(24h)</td></tr><tr><td>121 或 21</td><td>yyyy-mm-dd hh:mi:ss.mmm(24h)</td></tr><tr><td>126</td><td>yyyy-mm-ddThh:mm:ss.mmm（没有空格）</td></tr><tr><td>130</td><td>dd mon yyyy hh:mi:ss:mmmAM</td></tr><tr><td>131</td><td>dd/mm/yy hh:mi:ss:mmmAM</td></tr></tbody></table><p>如使用如下语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select convert(varchar(20),getdate(),101) as date1,</span><br><span class="line">convert(varchar(20),getdate(),112) as date2,</span><br><span class="line">convert(varchar(30),getdate(),126) as date3</span><br></pre></td></tr></table></figure><p>会得到以下结果</p><table><thead><tr><th>date1</th><th>date2</th><th>date3</th></tr></thead><tbody><tr><td>04/15/2020</td><td>20200415</td><td>2020-04-15T14:31:43.143</td></tr></tbody></table><h2 id="Date-和-运算符"><a href="#Date-和-运算符" class="headerlink" title="Date 和 运算符"></a>Date 和 运算符</h2><p>Date 类型是可以使用 = , &gt; , &lt; , &gt;= 和 &lt;= 等运算符的，时间越晚，数值越大</p><p>比如</p><p>我们比较两个时间的大小，就可以用 &gt; 运算符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(&#39;2020-01-01&#39;&gt;&#39;2020-01-02&#39;)</span><br><span class="line">select &#39;Yse&#39; as result;</span><br><span class="line">else select &#39;No&#39; as result;</span><br></pre></td></tr></table></figure><p>结果如下</p><table><thead><tr><th>result</th></tr></thead><tbody><tr><td>No</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;SQL-server-Date-数据类型&quot;&gt;&lt;a href=&quot;#SQL-server-Date-数据类型&quot; class=&quot;headerlink&quot; title=&quot;SQL server Date 数据类型&quot;&gt;&lt;/a&gt;SQL server Date 数据类型&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在图书管理系统的练习中，想到可以通过日期筛选图书&lt;/p&gt;
&lt;p&gt;然后又是因为用到了存储过程，所以时间操作必定要在数据库中完成&lt;/p&gt;
&lt;p&gt;所以就简单的看了下 SQL server 的 Date 数据类型和相关的内置函数&lt;/p&gt;</summary>
    
    
    
    
    <category term="SQL server" scheme="http://example.com/tags/SQL-server/"/>
    
    <category term="Date 数据类型" scheme="http://example.com/tags/Date-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
</feed>
