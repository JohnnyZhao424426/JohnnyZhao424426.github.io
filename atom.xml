<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>昭佳宁的博客</title>
  
  <subtitle>Johnny&#39;s Blog</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-09-24T13:39:55.161Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Johnny Zhao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python中的序列</title>
    <link href="http://example.com/2020/09/24/Python%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2020/09/24/Python%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2020-09-24T12:30:00.000Z</published>
    <updated>2020-09-24T13:39:55.161Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文总结于 <code>Python Docs</code> ，仅供个人学习使用。</p></blockquote><h1 id="三种序列类型"><a href="#三种序列类型" class="headerlink" title="三种序列类型"></a>三种序列类型</h1><p>在 <code>Python</code> 语言中，共有三种基本的序列类型，分别是：</p><ul><li>list</li><li>tuple</li><li>range</li></ul><p>三者大同小异，下面对他们进行介绍</p><a id="more"></a><h2 id="通用序列操作"><a href="#通用序列操作" class="headerlink" title="通用序列操作"></a>通用序列操作</h2><p>大多数序列类型，包括可变类型和不可变类型都支持下表中的操作。</p><p>此表按优先级升序列出了序列操作。 在表格中，<em>s</em> 和 <em>t</em> 是具有相同类型的序列，<em>n</em>, <em>i</em>, <em>j</em> 和 <em>k</em> 是整数而 <em>x</em> 是任何满足 <em>s</em> 所规定的类型和值限制的任意对象。</p><p><code>in</code> 和 <code>not in</code> 操作具有与比较操作相同的优先级。 <code>+</code> (拼接) 和 <code>*</code> (重复) 操作具有与对应数值运算相同的优先级。</p><table><thead><tr><th align="left">运算</th><th align="left">结果：</th></tr></thead><tbody><tr><td align="left"><code>x in s</code></td><td align="left">如果 <em>s</em> 中的某项等于 <em>x</em> 则结果为 <code>True</code>，否则为 <code>False</code></td></tr><tr><td align="left"><code>x not in s</code></td><td align="left">如果 <em>s</em> 中的某项等于 <em>x</em> 则结果为 <code>False</code>，否则为 <code>True</code></td></tr><tr><td align="left"><code>s + t</code></td><td align="left"><em>s</em> 与 <em>t</em> 相拼接</td></tr><tr><td align="left"><code>s * n</code> 或 <code>n * s</code></td><td align="left">相当于 <em>s</em> 与自身进行 <em>n</em> 次拼接</td></tr><tr><td align="left"><code>s[i]</code></td><td align="left"><em>s</em> 的第 <em>i</em> 项，起始为 0</td></tr><tr><td align="left"><code>s[i:j]</code></td><td align="left"><em>s</em> 从 <em>i</em> 到 <em>j</em> 的切片</td></tr><tr><td align="left"><code>s[i:j:k]</code></td><td align="left"><em>s</em> 从 <em>i</em> 到 <em>j</em> 步长为 <em>k</em> 的切片</td></tr><tr><td align="left"><code>len(s)</code></td><td align="left"><em>s</em> 的长度</td></tr><tr><td align="left"><code>min(s)</code></td><td align="left"><em>s</em> 的最小项</td></tr></tbody></table><p>相同类型的序列也支持比较。 特别地，tuple 和 list 的比较是通过比较对应元素的字典顺序。 这意味着想要比较结果相等，则每个元素比较结果都必须相等，并且两个序列长度必须相同。</p><blockquote><p>其中需要注意：</p><ol><li><p>小于 <code>0</code> 的 <em>n</em> 值会被当作 <code>0</code> 来处理 (生成一个与 <em>s</em> 同类型的空序列)。 请注意序列 <em>s</em> 中的项并不会被拷贝；它们会被多次引用。</p><p>比如：</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lists = [[]] * <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lists</span><br><span class="line">[[], [], []]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lists[<span class="number">0</span>].append(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lists</span><br><span class="line">[[<span class="number">3</span>], [<span class="number">3</span>], [<span class="number">3</span>]]</span><br></pre></td></tr></table></figure><ul><li>具体的原因在于 <code>[[]]</code> 是一个包含了一个空列表的单元素列表，所以 <code>[[]] * 3</code> 结果中的三个元素都是对这一个空列表的引用。 修改 <code>lists</code> 中的任何一个元素实际上都是对这一个空列表的修改。 你可以用以下方式创建以不同列表为元素的列表:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lists = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lists[<span class="number">0</span>].append(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lists[<span class="number">1</span>].append(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lists[<span class="number">2</span>].append(<span class="number">7</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lists</span><br><span class="line">[[<span class="number">3</span>], [<span class="number">5</span>], [<span class="number">7</span>]]</span><br></pre></td></tr></table></figure><ol start="2"><li><p>如果 <em>i</em> 或 <em>j</em> 为负值，则索引顺序是相对于序列 <em>s</em> 的末尾: 索引号会被替换为 <code>len(s) + i</code> 或 <code>len(s) + j</code>。 但要注意 <code>-0</code> 仍然为 <code>0</code>。</p><p>如:</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list[<span class="number">-1</span>]</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list[len(list) + <span class="number">-1</span>]</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list[<span class="number">-0</span>]</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>s* 从 <em>i</em> 到 <em>j</em> 的切片被定义为所有满足 <code>i &lt;= k &lt; j</code> 的索引号 <em>k</em> 的项组成的序列。 如果 <em>i</em> 或 <em>j</em> 大于 <code>len(s)</code>，则使用 <code>len(s)</code>。 如果 <em>i</em> 被省略或为 <code>None</code>，则使用 <code>0</code>。 如果 <em>j</em> 被省略或为 <code>None</code>，则使用 <code>len(s)</code>。 如果 <em>i</em> 大于等于 <em>j</em>，则切片为空。</p><p>如:</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list[<span class="number">0</span>: <span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list[: <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list[<span class="number">2</span>: <span class="number">1</span>]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><ol start="4"><li><p><em>s</em> 从 <em>i</em> 到 <em>j</em> 步长为 <em>k</em> 的切片被定义为所有满足 <code>0 &lt;= n &lt; (j-i)/k</code> 的索引号 <code>x = i + n*k</code> 的项组成的序列。 换句话说，索引号为 <code>i</code>, <code>i+k</code>, <code>i+2*k</code>, <code>i+3*k</code>，以此类推，当达到 <em>j</em> 时停止 (但一定不包括 <em>j</em>)。 当 <em>k</em> 为正值时，<em>i</em> 和 <em>j</em> 会被减至不大于 <code>len(s)</code>。 当 <em>k</em> 为负值时，<em>i</em> 和 <em>j</em> 会被减至不大于 <code>len(s) - 1</code>。 如果 <em>i</em> 或 <em>j</em> 被省略或为 <code>None</code>，它们会成为“终止”值 (是哪一端的终止值则取决于 <em>k</em> 的符号)。 请注意，<em>k</em> 不可为零。 如果 <em>k</em> 为 <code>None</code>，则当作 <code>1</code> 处理。</p><p>如:</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list[<span class="number">0</span>: <span class="number">2</span>: <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list[<span class="number">0</span>: <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><ol start="5"><li>拼接不可变序列总是会生成新的对象。 这意味着通过重复拼接来构建序列的运行时开销将会基于序列总长度的乘方。 想要获得线性的运行时开销，你必须改用下列替代方案之一：</li></ol><ul><li>如果拼接 <code>str</code>对象，你可以构建一个列表并在最后使用 <code>str.join()</code>或是写入一个 <code>io.StringIO</code>实例并在结束时获取它的值</li><li>如果拼接 <code>bytes</code> 对象，你可以类似地使用 <code>bytes.join()</code> 或 <code>io.BytesIO</code>，或者你也可以使用 <code>bytearray</code> 对象进行原地拼接。 <code>bytearray</code> 对象是可变的，并且具有高效的重分配机制</li><li>如果拼接 <code>tuple</code>对象，请改为扩展 <code>list</code> 类</li></ul><ol start="6"><li><p>某些序列类型 (例如 <code>range</code>) 仅支持遵循特定模式的项序列，因此并不支持序列拼接或重复。</p></li><li><p>当 <em>x</em> 在 <em>s</em> 中找不到时 <code>index</code> 会引发 <code>ValueError</code>。 不是所有实现都支持传入额外参数 <em>i</em> 和 <em>j</em>。 这两个参数允许高效地搜索序列的子序列。 传入这两个额外参数大致相当于使用 <code>s[i:j].index(x)</code>，但是不会复制任何数据，并且返回的索引是相对于序列的开头而非切片的开头。</p></li></ol></blockquote><h3 id="不可变序列类型"><a href="#不可变序列类型" class="headerlink" title="不可变序列类型"></a>不可变序列类型</h3><p>不可变序列类型普遍实现而可变序列类型未实现的唯一操作就是对<code>hash()</code> 内置函数的支持。</p><p>这种支持允许不可变类型，例如 <code>tuple</code>实例被用作 <code>dict</code>键，以及存储在 <code>set</code>和 <code>frozenset</code>实例中。</p><p>尝试对包含有不可哈希值的不可变序列进行哈希运算将会导致 <code>TypeError</code>。</p><h3 id="可变序列类型"><a href="#可变序列类型" class="headerlink" title="可变序列类型"></a>可变序列类型</h3><p>以下表格中的操作是在可变序列类型上定义的。 <code>collections.abc.MutableSequence</code> ABC 被提供用来更容易地在自定义序列类型上正确实现这些操作。</p><p>表格中的 <em>s</em> 是可变序列类型的实例，<em>t</em> 是任意可迭代对象，而 <em>x</em> 是符合对 <em>s</em> 所规定类型与值限制的任何对象 (例如，<code>bytearray</code> 仅接受满足 <code>0 &lt;= x &lt;= 255</code> 值限制的整数)。</p><table><thead><tr><th align="left">运算</th><th align="left">结果：</th></tr></thead><tbody><tr><td align="left"><code>s[i] = x</code></td><td align="left">将 <em>s</em> 的第 <em>i</em> 项替换为 <em>x</em></td></tr><tr><td align="left"><code>s[i:j] = t</code></td><td align="left">将 <em>s</em> 从 <em>i</em> 到 <em>j</em> 的切片替换为可迭代对象 <em>t</em> 的内容</td></tr><tr><td align="left"><code>del s[i:j]</code></td><td align="left">等同于 <code>s[i:j] = []</code></td></tr><tr><td align="left"><code>s[i:j:k] = t</code></td><td align="left">将 <code>s[i:j:k]</code> 的元素替换为 <em>t</em> 的元素</td></tr><tr><td align="left"><code>del s[i:j:k]</code></td><td align="left">从列表中移除 <code>s[i:j:k]</code> 的元素</td></tr><tr><td align="left"><code>s.append(x)</code></td><td align="left">将 <em>x</em> 添加到序列的末尾 (等同于 <code>s[len(s):len(s)] = [x]</code>)</td></tr><tr><td align="left"><code>s.clear()</code></td><td align="left">从 <em>s</em> 中移除所有项 (等同于 <code>del s[:]</code>)</td></tr><tr><td align="left"><code>s.copy()</code></td><td align="left">创建 <em>s</em> 的浅拷贝 (等同于 <code>s[:]</code>)</td></tr><tr><td align="left"><code>s.extend(t)</code> 或 <code>s += t</code></td><td align="left">用 <em>t</em> 的内容扩展 <em>s</em> (基本上等同于 <code>s[len(s):len(s)] = t</code>)</td></tr></tbody></table><blockquote><p>其中需要注意:</p><ol><li><em>t</em> 必须与它所替换的切片具有相同的长度。</li><li>可选参数 <em>i</em> 默认为 <code>-1</code>，因此在默认情况下会移除并返回最后一项。</li><li>当在 <em>s</em> 中找不到 <em>x</em> 时 <code>remove</code> 操作会引发 <code>ValueError</code>。</li><li>当反转大尺寸序列时 <code>reverse()</code> 方法会原地修改该序列以保证空间经济性。 为提醒用户此操作是通过间接影响进行的，它并不会返回反转后的序列。</li><li><em>n</em> 值为一个整数，或是一个实现了 <code>__index__()</code> 的对象。 <em>n</em> 值为零或负数将清空序列。 序列中的项不会被拷贝；它们会被多次引用。</li></ol></blockquote><blockquote><p>持续更新中……</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文总结于 &lt;code&gt;Python Docs&lt;/code&gt; ，仅供个人学习使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;三种序列类型&quot;&gt;&lt;a href=&quot;#三种序列类型&quot; class=&quot;headerlink&quot; title=&quot;三种序列类型&quot;&gt;&lt;/a&gt;三种序列类型&lt;/h1&gt;&lt;p&gt;在 &lt;code&gt;Python&lt;/code&gt; 语言中，共有三种基本的序列类型，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;list&lt;/li&gt;
&lt;li&gt;tuple&lt;/li&gt;
&lt;li&gt;range&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三者大同小异，下面对他们进行介绍&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>layer</title>
    <link href="http://example.com/2020/09/15/Layer-iframe%E5%B1%82%20%E5%85%B3%E9%97%AD%E8%87%AA%E5%B7%B1/"/>
    <id>http://example.com/2020/09/15/Layer-iframe%E5%B1%82%20%E5%85%B3%E9%97%AD%E8%87%AA%E5%B7%B1/</id>
    <published>2020-09-15T12:12:00.000Z</published>
    <updated>2020-09-24T13:37:38.693Z</updated>
    
    <content type="html"><![CDATA[<h1 id="layer-关闭自己"><a href="#layer-关闭自己" class="headerlink" title="layer 关闭自己"></a>layer 关闭自己</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> index = parent.layer.getFrameIndex(<span class="built_in">window</span>.name); </span><br><span class="line">parent.layer.close(index); </span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;layer-关闭自己&quot;&gt;&lt;a href=&quot;#layer-关闭自己&quot; class=&quot;headerlink&quot; title=&quot;layer 关闭自己&quot;&gt;&lt;/a&gt;layer 关闭自己&lt;/h1&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; index = parent.layer.getFrameIndex(&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.name); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;parent.layer.close(index); &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="layui" scheme="http://example.com/tags/layui/"/>
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>js数组</title>
    <link href="http://example.com/2020/09/11/JavaScript%E4%B8%AD%E7%9A%84%E6%9F%90%E4%BA%9B%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2020/09/11/JavaScript%E4%B8%AD%E7%9A%84%E6%9F%90%E4%BA%9B%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/</id>
    <published>2020-09-11T04:11:00.000Z</published>
    <updated>2020-09-24T23:36:27.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="删除数组中下标为-index-的元素"><a href="#删除数组中下标为-index-的元素" class="headerlink" title="删除数组中下标为 index 的元素"></a>删除数组中下标为 <code>index</code> 的元素</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.splice(index, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="删除数组中符合条件的元素"><a href="#删除数组中符合条件的元素" class="headerlink" title="删除数组中符合条件的元素"></a>删除数组中符合条件的元素</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, arr</span>) </span>&#123;</span><br><span class="line">               <span class="keyword">if</span> ( <span class="comment">/*item 满足条件*/</span> ) &#123;</span><br><span class="line">                   arr.splice(index, <span class="number">1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><h1 id="数组中的元素交换位置"><a href="#数组中的元素交换位置" class="headerlink" title="数组中的元素交换位置"></a>数组中的元素交换位置</h1><p><code>index1</code> 位置上的元素替换为 <code>index2</code> 位置上的元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.splice(index1, <span class="number">1</span> , array[index2])</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;删除数组中下标为-index-的元素&quot;&gt;&lt;a href=&quot;#删除数组中下标为-index-的元素&quot; class=&quot;headerlink&quot; title=&quot;删除数组中下标为 index 的元素&quot;&gt;&lt;/a&gt;删除数组中下标为 &lt;code&gt;index&lt;/code&gt; 的元素&lt;/h1&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;arr.splice(index, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>layui-nav</title>
    <link href="http://example.com/2020/08/29/Layui-Nav/"/>
    <id>http://example.com/2020/08/29/Layui-Nav/</id>
    <published>2020-08-29T07:23:00.000Z</published>
    <updated>2020-09-24T13:40:22.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue-动态改变导航条-渲染失败的问题"><a href="#vue-动态改变导航条-渲染失败的问题" class="headerlink" title="vue 动态改变导航条 渲染失败的问题"></a>vue 动态改变导航条 渲染失败的问题</h1><p>在 <code>updated</code> 后调用 <code>layui.element.render(&#39;nav&#39;,layfilter)</code> 方法即可</p><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;vue-动态改变导航条-渲染失败的问题&quot;&gt;&lt;a href=&quot;#vue-动态改变导航条-渲染失败的问题&quot; class=&quot;headerlink&quot; title=&quot;vue 动态改变导航条 渲染失败的问题&quot;&gt;&lt;/a&gt;vue 动态改变导航条 渲染失败的问题&lt;/h1&gt;&lt;p&gt;在 &lt;code&gt;updated&lt;/code&gt; 后调用 &lt;code&gt;layui.element.render(&amp;#39;nav&amp;#39;,layfilter)&lt;/code&gt; 方法即可&lt;/p&gt;</summary>
    
    
    
    
    <category term="layui" scheme="http://example.com/tags/layui/"/>
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>ASP.NET MVC中的Global.asax文件</title>
    <link href="http://example.com/2020/05/19/ASP.NET%20MVC%E4%B8%AD%E7%9A%84Global.asax%E6%96%87%E4%BB%B6/"/>
    <id>http://example.com/2020/05/19/ASP.NET%20MVC%E4%B8%AD%E7%9A%84Global.asax%E6%96%87%E4%BB%B6/</id>
    <published>2020-05-19T13:20:00.000Z</published>
    <updated>2020-05-19T13:32:54.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="global-asax文件概述"><a href="#global-asax文件概述" class="headerlink" title="global.asax文件概述"></a>global.asax文件概述</h1><p>Global.asax这个文件包含全局应用程序事件的事件处理程序。它响应应用程序级别和会话级别事件的代码。　　<br>运行时， Global.asax 将被编译成一个动态生成的 <code>.NET Framework</code> 类，该类是从 <code>HttpApplication</code> 基类派生的。<br>因此在 Global.asax 中的代码可以访问 <code>HttpApplication</code> 类中所有的 <code>public</code> 或者 <code>protected</code> 的成员<br>Global.asax 不被用户直接请求，但 Global.asax 中的代码会被自动执行来响应特定的应用程序事件。<br>Global.asax 是可选的，而且在一个 web 项目中是唯一的，它应该处于网站的根目录。</p><a id="more"></a><h1 id="一个请求的完整处理过程"><a href="#一个请求的完整处理过程" class="headerlink" title="一个请求的完整处理过程"></a>一个请求的完整处理过程</h1><p>以下过程由 <code>Internet Information Service（inetinfo.exe）（IIS）</code>执行</p><ul><li>客户端发出请求</li><li>验证请求</li><li>给请求授权</li><li>确定请求的缓存</li><li>获取缓存状态</li><li>在请求的处理程序执行前</li><li>http 处理程序执行请求 （asp.net 页面由 aspnet_wp.exe 执行）</li><li>在请求的处理程序执行后</li><li>释放请求状态</li><li>更新请求缓存</li><li>请求结束</li></ul><h1 id="Global-asax中的事件"><a href="#Global-asax中的事件" class="headerlink" title="Global.asax中的事件"></a>Global.asax中的事件</h1><p>Global.asax中的所有事件可以分成两种，一种是满足特定事件时才会被触发，一种是每次请求都会被按照顺序执行的事件。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MvcApplication</span> : <span class="title">System.Web.HttpApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Application_Start</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//不是每次请求都调用</span></span><br><span class="line">        <span class="comment">//在Web应用程序的生命周期里就执行一次</span></span><br><span class="line">        <span class="comment">//在应用程序第一次启动和应用程序域创建事被调用</span></span><br><span class="line">        <span class="comment">//适合处理应用程序范围的初始化代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Application_End</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//不是每次请求都调用</span></span><br><span class="line">        <span class="comment">//在应用程序关闭时运行的代码，在最后一个HttpApplication销毁之后执行</span></span><br><span class="line">        <span class="comment">//比如IIS重启，文件更新，进程回收导致应用程序转换到另一个应用程序域</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Session_Start</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//不是每次请求都调用</span></span><br><span class="line">        <span class="comment">//会话开始时执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Session_End</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//不是每次请求都调用</span></span><br><span class="line">        <span class="comment">//会话结束或过期时执行</span></span><br><span class="line">        <span class="comment">//不管在代码中显式的清空Session或者Session超时自动过期，此方法都将被调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Application_Init</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//不是每次请求都调用</span></span><br><span class="line">        <span class="comment">//在每一个HttpApplication实例初始化的时候执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Application_Disposed</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//不是每次请求都调用</span></span><br><span class="line">        <span class="comment">//在应用程序被关闭一段时间之后，在.net垃圾回收器准备回收它占用的内存的时候被调用。</span></span><br><span class="line">        <span class="comment">//在每一个HttpApplication实例被销毁之前执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Application_Error</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//不是每次请求都调用</span></span><br><span class="line">        <span class="comment">//所有没有处理的错误都会导致这个方法的执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*********************************************************************/</span></span><br><span class="line">    <span class="comment">//每次请求都会按照顺序执行以下事件</span></span><br><span class="line">    <span class="comment">/*********************************************************************/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Application_BeginRequest</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//每次请求时第一个出发的事件，这个方法第一个执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Application_AuthenticateRequest</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//在执行验证前发生，这是创建验证逻辑的起点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Application_AuthorizeRequest</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//当安全模块已经验证了当前用户的授权时执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Application_ResolveRequestCache</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//当ASP.NET完成授权事件以使缓存模块从缓存中为请求提供服务时发生，从而跳过处理程序（页面或者是WebService）的执行。</span></span><br><span class="line">        <span class="comment">//这样做可以改善网站的性能，这个事件还可以用来判断正文是不是从Cache中得到的。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//在这个时候，请求将被转交给合适程序。例如：web窗体将被编译并完成实例化</span></span><br><span class="line">    <span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Application_AcquireRequestState</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//读取了Session所需的特定信息并且在把这些信息填充到Session之前执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Application_PreRequestHandlerExecute</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//在合适的处理程序执行请求前调用</span></span><br><span class="line">        <span class="comment">//这个时候，Session就可以用了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//-------------------------------------------------</span></span><br><span class="line">    <span class="comment">//在这个时候，页面代码将会被执行，页面呈现为HTML</span></span><br><span class="line">    <span class="comment">//-------------------------------------------------</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Application_PostRequestHandlerExecute</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//当处理程序完成对请求的处理后被调用。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Application_ReleaseRequestState</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//释放请求状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Application_UpdateRequestCache</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//为了后续的请求，更新响应缓存时被调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Application_EndRequest</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//EndRequest是在响应Request时最后一个触发的事件</span></span><br><span class="line">        <span class="comment">//但在对象被释放或者从新建立以前，适合在这个时候清理代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Application_PreSendRequestHeaders</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//向客户端发送Http标头之前被调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Application_PreSendRequestContent</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//向客户端发送Http正文之前被调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;global-asax文件概述&quot;&gt;&lt;a href=&quot;#global-asax文件概述&quot; class=&quot;headerlink&quot; title=&quot;global.asax文件概述&quot;&gt;&lt;/a&gt;global.asax文件概述&lt;/h1&gt;&lt;p&gt;Global.asax这个文件包含全局应用程序事件的事件处理程序。它响应应用程序级别和会话级别事件的代码。　　&lt;br&gt;运行时， Global.asax 将被编译成一个动态生成的 &lt;code&gt;.NET Framework&lt;/code&gt; 类，该类是从 &lt;code&gt;HttpApplication&lt;/code&gt; 基类派生的。&lt;br&gt;因此在 Global.asax 中的代码可以访问 &lt;code&gt;HttpApplication&lt;/code&gt; 类中所有的 &lt;code&gt;public&lt;/code&gt; 或者 &lt;code&gt;protected&lt;/code&gt; 的成员&lt;br&gt;Global.asax 不被用户直接请求，但 Global.asax 中的代码会被自动执行来响应特定的应用程序事件。&lt;br&gt;Global.asax 是可选的，而且在一个 web 项目中是唯一的，它应该处于网站的根目录。&lt;/p&gt;</summary>
    
    
    
    
    <category term=".NET" scheme="http://example.com/tags/NET/"/>
    
    <category term="MVC" scheme="http://example.com/tags/MVC/"/>
    
    <category term="Global" scheme="http://example.com/tags/Global/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式 数字判断</title>
    <link href="http://example.com/2020/05/18/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%20%E6%95%B0%E5%AD%97%E5%88%A4%E6%96%AD/"/>
    <id>http://example.com/2020/05/18/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%20%E6%95%B0%E5%AD%97%E5%88%A4%E6%96%AD/</id>
    <published>2020-05-18T13:05:00.000Z</published>
    <updated>2020-09-24T13:38:47.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="整数判断"><a href="#整数判断" class="headerlink" title="整数判断"></a>整数判断</h1><ol><li>判断整数<br><code>&quot;^-?\d+$&quot;</code></li><li>判断正整数<br><code>&quot;^\d*[1-9]\d*$&quot;</code></li><li>判断负整数<br><code>&quot;^-\d*[1-9]\d*$&quot;</code><a id="more"></a></li><li>判断非正整数<br><code>&quot;^((-\d+)|(0+))$&quot;</code></li><li>判断非负整数<br><code>&quot;^\d+$&quot;</code></li></ol><h1 id="浮点数判断"><a href="#浮点数判断" class="headerlink" title="浮点数判断"></a>浮点数判断</h1><ol><li>判断浮点数<br><code>&quot;^(-?\d+)(\.\d+)?$&quot;</code></li><li>判断正浮点数<br><code>&quot;^((\d+\.\d*[1-9]\d*)|(\d*[1-9]\d*\.\d+)|(\d*[1-9]\d*))$&quot;</code></li><li>判断负浮点数<br><code>&quot;^(-((\d+\.\d*[1-9]\d*)|(\d*[1-9]\d*\.\d+)|(\d*[1-9]\d*)))$&quot;</code></li><li>判断非正浮点数<br><code>&quot;^((-\d+(\.\d+)?)|(0+(\.0+)?))$&quot;</code></li><li>判断非负浮点数<br><code>&quot;^\d+(\.\d+)?$&quot;</code></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;整数判断&quot;&gt;&lt;a href=&quot;#整数判断&quot; class=&quot;headerlink&quot; title=&quot;整数判断&quot;&gt;&lt;/a&gt;整数判断&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;判断整数&lt;br&gt;&lt;code&gt;&amp;quot;^-?\d+$&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;判断正整数&lt;br&gt;&lt;code&gt;&amp;quot;^\d*[1-9]\d*$&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;判断负整数&lt;br&gt;&lt;code&gt;&amp;quot;^-\d*[1-9]\d*$&amp;quot;&lt;/code&gt;</summary>
    
    
    
    
    <category term="Regex" scheme="http://example.com/tags/Regex/"/>
    
    <category term="正则" scheme="http://example.com/tags/%E6%AD%A3%E5%88%99/"/>
    
    <category term="数字判断" scheme="http://example.com/tags/%E6%95%B0%E5%AD%97%E5%88%A4%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>c#中的Cache缓存技术</title>
    <link href="http://example.com/2020/04/15/C#%E4%B8%AD%E7%9A%84Cache%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/"/>
    <id>http://example.com/2020/04/15/C#%E4%B8%AD%E7%9A%84Cache%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF/</id>
    <published>2020-04-14T16:00:00.000Z</published>
    <updated>2020-05-19T13:33:25.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c-中的Cache缓存技术"><a href="#c-中的Cache缓存技术" class="headerlink" title="c#中的Cache缓存技术"></a>c#中的Cache缓存技术</h1><h2 id="Cache缓存类"><a href="#Cache缓存类" class="headerlink" title="Cache缓存类"></a>Cache缓存类</h2><ul><li><p>1、HttpRuntime.Cache 相当于就是一个缓存具体实现类，这个类虽然被放在了 System.Web 命名空间下了。但是非 Web 应用也是可以拿来用的。</p></li><li><p>2、HttpContext.Cache 是对上述缓存类的封装，由于封装到了 HttpContext ，局限于只能在知道 HttpContext 下使用，即只能用于 Web 应用。</p></li></ul><p>综上所属，在可以的条件，尽量用 HttpRuntime.Cache ，而不是用 HttpContext.Cache 。 </p><a id="more"></a><h2 id="Cache缓存数据规则"><a href="#Cache缓存数据规则" class="headerlink" title="Cache缓存数据规则"></a>Cache缓存数据规则</h2><p>Cache有以下几条缓存数据的规则。</p><ul><li><p>第一，数据可能会被频繁的被使用，这种数据可以缓存。</p></li><li><p>第二，数据的访问频率非常高，或者一个数据的访问频率不高，但是它的生存周期很长，这样的数据最好也缓存起来。</p></li><li><p>第三是一个常常被忽略的问题，有时候我们缓存了太多数据，通常在一台 X86 的机子上，如果你要缓存的数据超过 800M 的话，就会出现内存溢出的错误。所以说缓存是有限的。换名话说，你应该估计缓存集的大小，把缓存集的大小限制在 10 以内，否则它可能会出问题。</p></li></ul><h2 id="Cache的操作"><a href="#Cache的操作" class="headerlink" title="Cache的操作"></a>Cache的操作</h2><h3 id="cache的创建"><a href="#cache的创建" class="headerlink" title="cache的创建"></a>cache的创建</h3><p><code>cache.Insert(string key,object value,CacheDependency dependencies,DateTime absoluteExpiration,TimeSpan slidingExpiration)</code></p><p><strong>只介绍有5个参数的情况，其实cache里有很几种重载</strong></p><ul><li><p>参数一：引用该对象的缓存键</p></li><li><p>参数二：要插入缓存中的对象</p></li><li><p>参数三：缓存键的依赖项，当任何依赖项更改时，该对象即无效，并从缓存中移除。 null.”&gt;如果没有依赖项，则此参数包含 null。</p></li><li><p>参数四：设置缓存过期时间</p></li><li><p>参数五：参数四的依赖项，如果使用绝对到期，null.”&gt;slidingExpiration parameter must beNoSlidingExpiration.”&gt;则 slidingExpiration 参数必须为 NoSlidingExpiration</p></li></ul><h3 id="销毁cache"><a href="#销毁cache" class="headerlink" title="销毁cache"></a>销毁cache</h3><p><code>cache.Remove(string key)</code></p><p>key为缓存键，通过缓存键进行销毁</p><h3 id="调用cache"><a href="#调用cache" class="headerlink" title="调用cache"></a>调用cache</h3><p>例如你存的是一个 DataTable 对象，调用如下： </p><p><code>DataTable finaltable = Cache[&quot;dt&quot;] as DataTable;</code></p><h3 id="一般什么时候选用cache"><a href="#一般什么时候选用cache" class="headerlink" title="一般什么时候选用cache"></a>一般什么时候选用cache</h3><p>cache一般用于数据较固定，访问较频繁的地方，例如在前端进行分页的时候，初始化把数据放入缓存中，然后每次分页都从缓存中取数据，这样减少了连接数据库的次数，提高了系统的性能。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;  </span><br><span class="line">&#x2F;&#x2F;&#x2F; 获取数据缓存  </span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;  </span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;cacheKey&quot;&gt;键&lt;&#x2F;param&gt;  </span><br><span class="line">public static object GetCache(string cacheKey)  </span><br><span class="line">&#123;  </span><br><span class="line">    var objCache &#x3D; HttpRuntime.Cache.Get(cacheKey);  </span><br><span class="line">    return objCache;  </span><br><span class="line">&#125;  </span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;  </span><br><span class="line">&#x2F;&#x2F;&#x2F; 设置数据缓存  </span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;  </span><br><span class="line">public static void SetCache(string cacheKey, object objObject)  </span><br><span class="line">&#123;  </span><br><span class="line">    var objCache &#x3D; HttpRuntime.Cache;  </span><br><span class="line">    objCache.Insert(cacheKey, objObject);  </span><br><span class="line">&#125;  </span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;  </span><br><span class="line">&#x2F;&#x2F;&#x2F; 设置数据缓存  </span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;  </span><br><span class="line">public static void SetCache(string cacheKey, object objObject, int timeout &#x3D; 7200)  </span><br><span class="line">&#123;  </span><br><span class="line">    try  </span><br><span class="line">    &#123;  </span><br><span class="line">        if (objObject &#x3D;&#x3D; null) return;  </span><br><span class="line">        var objCache &#x3D; HttpRuntime.Cache;  </span><br><span class="line">        &#x2F;&#x2F;相对过期  </span><br><span class="line">        &#x2F;&#x2F;objCache.Insert(cacheKey, objObject, null, DateTime.MaxValue, timeout, CacheItemPriority.NotRemovable, null);  </span><br><span class="line">        &#x2F;&#x2F;绝对过期时间  </span><br><span class="line">        objCache.Insert(cacheKey, objObject, null, DateTime.Now.AddSeconds(timeout), TimeSpan.Zero, CacheItemPriority.High, null);  </span><br><span class="line">    &#125;  </span><br><span class="line">    catch (Exception)  </span><br><span class="line">    &#123;  </span><br><span class="line">        &#x2F;&#x2F;throw;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;  </span><br><span class="line">&#x2F;&#x2F;&#x2F; 移除指定数据缓存  </span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;  </span><br><span class="line">public static void RemoveAllCache(string cacheKey)  </span><br><span class="line">&#123;  </span><br><span class="line">    var cache &#x3D; HttpRuntime.Cache;  </span><br><span class="line">    cache.Remove(cacheKey);  </span><br><span class="line">&#125;  </span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;  </span><br><span class="line">&#x2F;&#x2F;&#x2F; 移除全部缓存  </span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;  </span><br><span class="line">public static void RemoveAllCache()  </span><br><span class="line">&#123;  </span><br><span class="line">    var cache &#x3D; HttpRuntime.Cache;  </span><br><span class="line">    var cacheEnum &#x3D; cache.GetEnumerator();  </span><br><span class="line">    while (cacheEnum.MoveNext())  </span><br><span class="line">    &#123;  </span><br><span class="line">        cache.Remove(cacheEnum.Key.ToString());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;c-中的Cache缓存技术&quot;&gt;&lt;a href=&quot;#c-中的Cache缓存技术&quot; class=&quot;headerlink&quot; title=&quot;c#中的Cache缓存技术&quot;&gt;&lt;/a&gt;c#中的Cache缓存技术&lt;/h1&gt;&lt;h2 id=&quot;Cache缓存类&quot;&gt;&lt;a href=&quot;#Cache缓存类&quot; class=&quot;headerlink&quot; title=&quot;Cache缓存类&quot;&gt;&lt;/a&gt;Cache缓存类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1、HttpRuntime.Cache 相当于就是一个缓存具体实现类，这个类虽然被放在了 System.Web 命名空间下了。但是非 Web 应用也是可以拿来用的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2、HttpContext.Cache 是对上述缓存类的封装，由于封装到了 HttpContext ，局限于只能在知道 HttpContext 下使用，即只能用于 Web 应用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;综上所属，在可以的条件，尽量用 HttpRuntime.Cache ，而不是用 HttpContext.Cache 。 &lt;/p&gt;</summary>
    
    
    
    
    <category term=".Net" scheme="http://example.com/tags/Net/"/>
    
    <category term="C#" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>SQL server Date 数据类型</title>
    <link href="http://example.com/2020/04/15/SQL%20Date%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://example.com/2020/04/15/SQL%20Date%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-04-14T16:00:00.000Z</published>
    <updated>2020-05-19T13:33:14.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL-server-Date-数据类型"><a href="#SQL-server-Date-数据类型" class="headerlink" title="SQL server Date 数据类型"></a>SQL server Date 数据类型</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在图书管理系统的练习中，想到可以通过日期筛选图书</p><p>然后又是因为用到了存储过程，所以时间操作必定要在数据库中完成</p><p>所以就简单的看了下 SQL server 的 Date 数据类型和相关的内置函数</p><a id="more"></a><h2 id="Date分类"><a href="#Date分类" class="headerlink" title="Date分类"></a>Date分类</h2><p>Date 数据类型可以分为一下几种：</p><table><thead><tr><th>数据类型</th><th>描述</th><th>样式</th><th>存储</th></tr></thead><tbody><tr><td>date</td><td>仅存储日期。从 0001 年 1 月 1 日 到 9999 年 12 月 31 日。</td><td>2020-04-15</td><td>3 bytes</td></tr><tr><td>time</td><td>仅存储时间。精度为 100 纳秒。</td><td>13:23:22.5333333</td><td>3-5 bytes</td></tr><tr><td>datetime</td><td>从 1753 年 1 月 1 日 到 9999 年 12 月 31 日 <br> 精度为 3.33 毫秒。</td><td>2020-04-15 13:24:16.920</td><td>8 bytes</td></tr><tr><td>datetime2</td><td>从 1753 年 1 月 1 日 到 9999 年 12 月 31 日 <br> 精度为 100 纳秒。（ datetime的升级版 ）</td><td>2020-04-15 13:26:07.8100000</td><td>6-8 bytes</td></tr><tr><td>smalldatetime</td><td>从 1900 年 1 月 1 日 到 2079 年 6 月 6 日 <br> 精度为 1 分钟。</td><td>2020-04-15 13:27:00</td><td>4 bytes</td></tr><tr><td>datetimeoffset</td><td>与 datetime2 相同 <br> 外加时区偏移。</td><td>2020-04-15 13:28:01.3133333 +00:00</td><td>8-10 bytes</td></tr><tr><td>timestamp</td><td>存储唯一的数字，每当创建或修改某行时，该数字会更新。 <br> timestamp 基于内部时钟，不对应真实时间。 <br> 每个表只能有一个 timestamp 变量。（ 时间戳 ）</td><td>0x0000000000000FA0</td><td></td></tr></tbody></table><p>若需要手写日期类型，只需要按照样式的仿写然后用引号括起来即可</p><p>如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">declare @timeDemo datetime</span><br><span class="line">set @timeDemo &#x3D; &#39;2020-1-1 12:30:45.123&#39;</span><br><span class="line">select @timeDemo as timeDemo</span><br></pre></td></tr></table></figure><p>会得到以下结果</p><table><thead><tr><th>timeDemo</th></tr></thead><tbody><tr><td>2020-01-01 12:30:45.123</td></tr></tbody></table><p><strong>不过要注意，手写的内容必须合法，不然程序会报错！</strong></p><h2 id="Date映射关系"><a href="#Date映射关系" class="headerlink" title="Date映射关系"></a>Date映射关系</h2><table><thead><tr><th>SQL 数据类型</th><th>.NET Framework 类型</th><th>System.Data.SqlDbType</th></tr></thead><tbody><tr><td>date</td><td>System.DateTime</td><td>Date</td></tr><tr><td>time</td><td>System.TimeSpan</td><td>Time</td></tr><tr><td>datetime</td><td>System.DateTime</td><td>DateTime</td></tr><tr><td>datetime2</td><td>System.DateTime</td><td>DateTime2</td></tr><tr><td>smalldatetime</td><td>System.DateTime</td><td>DateTime</td></tr><tr><td>datetimeoffset</td><td>System.DateTimeOffset</td><td>DateTimeOffset</td></tr></tbody></table><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><h3 id="getdate"><a href="#getdate" class="headerlink" title="getdate()"></a>getdate()</h3><p>getdate() 函数从 SQL Server 返回当前的时间和日期。</p><p>如使用如下语句</p><p><code>select getdate() as timeDemo</code></p><p>会得到以下结果</p><table><thead><tr><th>timeDemo</th></tr></thead><tbody><tr><td>2020-04-15 13:41:33.317</td></tr></tbody></table><h3 id="datepart"><a href="#datepart" class="headerlink" title="datepart()"></a>datepart()</h3><p>datepart() 函数用于返回日期/时间的单独部分，比如年、月、日、小时、分钟等等。</p><p>语法</p><p><code>datepart(datepart,date)</code></p><p>其中，date 参数是合法的日期表达式。datepart 参数可以是下列的值：</p><table><thead><tr><th>datepart</th><th>缩写</th></tr></thead><tbody><tr><td>年</td><td>yy,yyyy</td></tr><tr><td>季度</td><td>qq,q</td></tr><tr><td>月</td><td>mm,m</td></tr><tr><td>年中的日</td><td>dy,y</td></tr><tr><td>日</td><td>dd,d</td></tr><tr><td>周</td><td>wk,ww</td></tr><tr><td>星期</td><td>dw,w</td></tr><tr><td>小时</td><td>hh</td></tr><tr><td>分钟</td><td>mi,n</td></tr><tr><td>秒</td><td>ss,s</td></tr><tr><td>毫秒</td><td>ms</td></tr><tr><td>微秒</td><td>mcs</td></tr><tr><td>纳秒</td><td>ns</td></tr></tbody></table><p>如使用如下语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select datepart(yyyy,getdate()) as Year,</span><br><span class="line">datepart(mm,getdate()) as Month,</span><br><span class="line">datepart(dd,getdate()) as Day</span><br></pre></td></tr></table></figure><p>会得到以下结果</p><table><thead><tr><th>Year</th><th>Month</th><th>Day</th></tr></thead><tbody><tr><td>2020</td><td>4</td><td>15</td></tr></tbody></table><h3 id="dateadd"><a href="#dateadd" class="headerlink" title="dateadd()"></a>dateadd()</h3><p>dateadd() 函数在日期中添加或减去指定的时间间隔。</p><p>语法</p><p><code>dateadd(datepart,number,date)</code></p><p>date 参数是合法的日期表达式。number 是您希望添加的间隔数；对于未来的时间，此数是正数，对于过去的时间，此数是负数。</p><p>datepart 参数上面已经介绍。</p><p>如使用如下语句</p><p><code>select dateadd(yy,1,&#39;2020-1-1&#39;) as nextYear</code></p><p>会得到以下结果</p><table><thead><tr><th>nextYear</th></tr></thead><tbody><tr><td>2021-01-01 00:00:00.000</td></tr></tbody></table><h3 id="datediff"><a href="#datediff" class="headerlink" title="datediff()"></a>datediff()</h3><p>datediff() 函数返回两个日期之间的时间。</p><p>语法</p><p><code>datediff(datepart,number,date)</code></p><p>startdate 和 enddate 参数是合法的日期表达式。</p><p>datepart 参数上面已经介绍。</p><p>如使用如下语句</p><p><code>select datediff(dd,&#39;2020-01-01&#39;,&#39;2020-01-02&#39;) as timeDiffer</code></p><p>会得到以下结果</p><table><thead><tr><th>timeDiffer</th></tr></thead><tbody><tr><td>1</td></tr></tbody></table><h3 id="convert"><a href="#convert" class="headerlink" title="convert()"></a>convert()</h3><p>convert() 函数是把日期转换为新数据类型的通用函数。<br>convert() 函数可以用不同的格式显示日期/时间数据。</p><p>语法</p><p><code>convert(data_type(length),data_to_be_converted,style)</code></p><p>data_type(length) 规定目标数据类型（带有可选的长度）。data_to_be_converted 含有需要转换的值。style 规定日期/时间的输出格式。</p><p>style可以使用下列值</p><table><thead><tr><th>style ID</th><th>style 格式</th></tr></thead><tbody><tr><td>100 或 0</td><td>mon dd yyyy hh:miAM （或者 PM）</td></tr><tr><td>101</td><td>mm/dd/yy</td></tr><tr><td>102</td><td>yy.mm.dd</td></tr><tr><td>103</td><td>dd/mm/yy</td></tr><tr><td>104</td><td>dd.mm.yy</td></tr><tr><td>105</td><td>dd-mm-yy</td></tr><tr><td>106</td><td>dd mon yy</td></tr><tr><td>107</td><td>Mon dd, yy</td></tr><tr><td>108</td><td>hh:mm:ss</td></tr><tr><td>109 或 9</td><td>mon dd yyyy hh:mi:ss:mmmAM（或者 PM）</td></tr><tr><td>110</td><td>mm-dd-yy</td></tr><tr><td>111</td><td>yy/mm/dd</td></tr><tr><td>112</td><td>yymmdd</td></tr><tr><td>113 或 13</td><td>dd mon yyyy hh:mm:ss:mmm(24h)</td></tr><tr><td>114</td><td>hh:mi:ss:mmm(24h)</td></tr><tr><td>120 或 20</td><td>yyyy-mm-dd hh:mi:ss(24h)</td></tr><tr><td>121 或 21</td><td>yyyy-mm-dd hh:mi:ss.mmm(24h)</td></tr><tr><td>126</td><td>yyyy-mm-ddThh:mm:ss.mmm（没有空格）</td></tr><tr><td>130</td><td>dd mon yyyy hh:mi:ss:mmmAM</td></tr><tr><td>131</td><td>dd/mm/yy hh:mi:ss:mmmAM</td></tr></tbody></table><p>如使用如下语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select convert(varchar(20),getdate(),101) as date1,</span><br><span class="line">convert(varchar(20),getdate(),112) as date2,</span><br><span class="line">convert(varchar(30),getdate(),126) as date3</span><br></pre></td></tr></table></figure><p>会得到以下结果</p><table><thead><tr><th>date1</th><th>date2</th><th>date3</th></tr></thead><tbody><tr><td>04/15/2020</td><td>20200415</td><td>2020-04-15T14:31:43.143</td></tr></tbody></table><h2 id="Date-和-运算符"><a href="#Date-和-运算符" class="headerlink" title="Date 和 运算符"></a>Date 和 运算符</h2><p>Date 类型是可以使用 = , &gt; , &lt; , &gt;= 和 &lt;= 等运算符的，时间越晚，数值越大</p><p>比如</p><p>我们比较两个时间的大小，就可以用 &gt; 运算符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(&#39;2020-01-01&#39;&gt;&#39;2020-01-02&#39;)</span><br><span class="line">select &#39;Yse&#39; as result;</span><br><span class="line">else select &#39;No&#39; as result;</span><br></pre></td></tr></table></figure><p>结果如下</p><table><thead><tr><th>result</th></tr></thead><tbody><tr><td>No</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;SQL-server-Date-数据类型&quot;&gt;&lt;a href=&quot;#SQL-server-Date-数据类型&quot; class=&quot;headerlink&quot; title=&quot;SQL server Date 数据类型&quot;&gt;&lt;/a&gt;SQL server Date 数据类型&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在图书管理系统的练习中，想到可以通过日期筛选图书&lt;/p&gt;
&lt;p&gt;然后又是因为用到了存储过程，所以时间操作必定要在数据库中完成&lt;/p&gt;
&lt;p&gt;所以就简单的看了下 SQL server 的 Date 数据类型和相关的内置函数&lt;/p&gt;</summary>
    
    
    
    
    <category term="SQL server" scheme="http://example.com/tags/SQL-server/"/>
    
    <category term="Date 数据类型" scheme="http://example.com/tags/Date-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
</feed>
